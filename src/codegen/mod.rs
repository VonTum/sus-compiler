pub mod system_verilog;
pub mod vhdl;
mod shared;

pub use system_verilog::VerilogCodegenBackend;
pub use vhdl::VHDLCodegenBackend;

use crate::{InstantiatedModule, Linker, Module};

use std::{fs::{self, File}, io::Write, path::PathBuf, rc::Rc};

pub trait CodeGenBackend {
    fn file_extension(&self) -> &str;
    fn output_dir_name(&self) -> &str;
    fn comment(&self) -> &str;
    fn codegen(&self, md: &Module, instance: &InstantiatedModule, linker: &Linker, use_latency: bool) -> String;

    fn make_output_file(&self, name: &str) -> File {
        let mut path = PathBuf::with_capacity(name.len() + self.output_dir_name().len() + self.file_extension().len() + 2);
        path.push(self.output_dir_name());
        fs::create_dir_all(&path).unwrap();
        path.push(name);
        path.set_extension(self.file_extension());
        let mut file = File::create(path).unwrap();
    
        file.write_fmt(format_args!(
            "{} DO NOT EDIT THIS FILE\n{} This file was generated with SUS Compiler {}\n",
            self.comment(),
            self.comment(),
            std::env!("CARGO_PKG_VERSION")
        ))
        .unwrap();
    
        file
    }

    fn codegen_instance(&self, inst: &InstantiatedModule, md: &Module, linker: &Linker, out_file: &mut File) {
        let inst_name = &inst.name;
        if inst.errors.did_error {
            println!("Instantiating error: {inst_name}");
            return; // Continue
        }
        println!("Instantiating success: {inst_name}");
        let code = self.codegen(md, &inst, linker, true); // hardcode use_latency = true for now. Maybe forever, we'll see
        write!(out_file, "{} {inst_name}\n{code}", self.comment()).unwrap();
    }

    fn codegen_to_file(&self, md: &Module, linker: &Linker) {
        let mut out_file = self.make_output_file(&md.link_info.name);
        md.instantiations.for_each_instance(|_template_args, inst| {
            self.codegen_instance(inst.as_ref(), md, linker, &mut out_file)
        });
    }

    fn codegen_with_dependencies(&self, linker: &Linker, md: &Module, file_name: &str) {
        let mut out_file = self.make_output_file(file_name);
        let mut top_level_instances: Vec<Rc<InstantiatedModule>> = Vec::new();
        md.instantiations.for_each_instance(|_template_args, inst| {
            top_level_instances.push(inst.clone());
        });
        let mut to_process_queue: Vec<(&InstantiatedModule, &Module)> = top_level_instances
            .iter()
            .map(|v| (v.as_ref(), md))
            .collect();
    
        let mut cur_idx = 0;
    
        while cur_idx < to_process_queue.len() {
            let (cur_instance, cur_md) = to_process_queue[cur_idx];
    
            for (_, sub_mod) in &cur_instance.submodules {
                let new_inst = sub_mod.instance.get().unwrap().as_ref();
    
                // Skip duplicates
                // Yeah yeah I know O(nÂ²) but this list shouldn't grow too big. Fix if needed
                if to_process_queue
                    .iter()
                    .any(|existing| std::ptr::eq(existing.0, new_inst))
                {
                    continue;
                }
    
                to_process_queue.push((new_inst, &linker.modules[sub_mod.module_uuid]));
            }
    
            self.codegen_instance(cur_instance, cur_md, linker, &mut out_file);
    
            cur_idx += 1;
        }
    }
}
